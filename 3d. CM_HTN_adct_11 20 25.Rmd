---
title: "2c. CM_mttau_02 24 25"
output: html_document
date: "2025-02-24"
---
# Getting packages into session
```{r packages, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, results = "hide")

library(haven) # inputting data 
library(tidyverse) # data mgmt
library(psych) # easy summary statistics
library(DT) # data tables
library(tableone) # easy table 1 
library(kableExtra) # format kable objects 
library(naniar) # for missingness 
library(survey) # for MSMs 
library(nnet) # multinormal regression
library(cobalt) # examining covariate balance
library(gt) # nice tables
library(broom) # making output nice
options(max.print=100000)
set.cobalt.options(binary='raw', continuous='std') # setting options for checking covariate balance 
```
```{css scroll box for code, include = FALSE}
pre {
  max-height: 300px;
  overflow-y: auto;
}

pre[class] {
  max-height: 100px;
}
```
# Uploading data
```{r upload data, include = FALSE}
load(file = "./analysis data/causmed_imp.Rdata") 
view(names(causmed_imp[[1]])) # getting names for reference

# creating dataset with imputed datasets stacked together
imp_stacked <- complete(causmed_imp, "long") # n=71840, v=66, 2 additional variables to label imputations + id 
str(imp_stacked)
summary(imp_stacked$".imp")
table(imp_stacked$".imp")
```

# Exposure weights
This accounts for exposure-outcome confounding (race/eth -> neuroimg). We estimate the probability of being Black or Hispanic (numerator), then the probability of being Black or Hispanic conditional on confounders of interest. Will start with age and gender as confounders here since there are very few true confounders of the E-O relationship (many are mediators). 

References:
- https://pmc.ncbi.nlm.nih.gov/articles/PMC3553264/
- https://pubmed.ncbi.nlm.nih.gov/36938776/
- https://pmc.ncbi.nlm.nih.gov/articles/PMC3710547

## Numerator model for exposure
```{r num exp, echo = TRUE}
# Prepping some lists/variables for for-loop 
m <- max(imp_stacked$".imp") # number of imputed datasets
num_race_adct <- list() # for fitted values
num_race <- list() # numerator for each race/ethnicity 

# For-loop to obtain numerator model for exposure 
for (i in seq_along(1:m)){
  
  # extract one imputed dataset at a time
  data <- imp_stacked %>% filter(`.imp` == i)
  
  # multinomial regression to obtain unconditional prob 
  # of being in a race/ethnic group
  num_race_adct[[i]] <- multinom(as.factor(ethnicity) ~ 1,
                                 data = data)
  
  # obtaining fitted values 
  num_race[[i]] <- num_race_adct[[i]]$fitted.values %>%
    as.data.frame() %>%
    rename(num_white = White,
           num_black = Black,
           num_hispanic = Hispanic)
  
}

# checking probabilities
## should be the same since we're just estimating unconditioanl probs here 
str(num_race)
summary(num_race[[20]]) # switch index to check all datasets

# cleaning up workspace for next section
rm(i, m, data, num_race_adct)
```
## Denominator model for exposure
```{r den exp, echo = TRUE}
# Denominator model: probability of being Black or Hispanic, conditional on age and gender 
# Prepping some lists/variables for for-loop 
m <- max(imp_stacked$".imp") # number of imputed datasets
den_race_adct <- list() # for fitted values
den_race <- list() # numerator for each race/ethnicity 

# For-loop to obtain numerator model for exposure 
for (i in seq_along(1:m)){
  
  # extract one imputed dataset at a time
  data <- imp_stacked %>% filter(`.imp` == i)
  
  # multinomial regression to obtain conditional prob 
  # of being in a race/ethnic group
  den_race_adct[[i]] <- multinom(as.factor(ethnicity) ~ 
                                   age_1 + # using visit 1 age here 
                                   as.factor(gender), 
                                  data = data)
  
  # obtaining fitted values 
  den_race[[i]] <- den_race_adct[[i]]$fitted.values %>%
    as.data.frame() %>%
    rename(den_white = White,
           den_black = Black,
           den_hispanic = Hispanic)
  
}

# checking probabilities
## should be the same since we're just estimating unconditioanl probs here 
str(den_race)
summary(den_race[[20]]) # switch index to check all datasets

# cleaning up workspace for next section
rm(i, m, data, den_race_adct)
```
## Calculating exposure weights
```{r exp IPW, echo = TRUE}
# Prepping some lists/variables for for-loop 
m <- max(imp_stacked$".imp") # number of imputed datasets
imp_stacked_exp <- list() # list for exposure weights 

# For-loop to obtain numerator model for exposure 
for (i in seq_along(1:m)){
  
  # extract one imputed dataset at a time
  data <- imp_stacked %>% filter(`.imp` == i)
  
  # Creating stabilized IPW for exposure
  imp_stacked_exp[[i]] <- data %>%
    
    # getting probabilities from the models above
    bind_cols(num_race[[i]],
              den_race[[i]]) %>% 
    
    # creating denominators based on exposure status
    mutate(num_exp = case_when(
      ethnicity == "Black" ~ num_black,
      ethnicity == "Hispanic" ~ num_hispanic,
      ethnicity == "White" ~ num_white,
      TRUE ~ NA)) %>%
    
    # creating denominators based on exposure status
    mutate(den_exp = case_when(
      ethnicity == "Black" ~ den_black,
      ethnicity == "Hispanic" ~ den_hispanic,
      ethnicity == "White" ~ den_white,
      TRUE ~ NA)) %>% 
    
    # creating exposure weights
    mutate(sw_exp = (num_exp/den_exp)) 
  
}
```
## Examining exposure IPWs
```{r check IPW exp, echo = TRUE}
# switch index to check each dataset separately 
summary(imp_stacked_exp[[5]]$num_exp) 
describeBy(imp_stacked_exp[[5]]$num_exp, 
           imp_stacked_exp[[5]]$ethnicity, 
           mat = TRUE) 

summary(imp_stacked_exp[[5]]$den_exp)
describeBy(imp_stacked_exp[[1]]$den_exp, 
           imp_stacked_exp[[1]]$ethnicity, 
           mat = TRUE) 

summary(imp_stacked_exp[[20]]$sw_exp) 
describeBy(imp_stacked_exp[[20]]$sw_exp, 
           imp_stacked_exp[[20]]$ethnicity, 
           mat = TRUE) 

bal.tab(ethnicity ~ age_1 + gender,
        data = imp_stacked_exp[[5]],
        weights = "sw_exp")

# cleaning up work space
rm(data, num_race, den_race)
```

# Mediator weights
This accounts for mediator-outcome confounding (HTN -> neuroimg). We estimate the probability of having hypertension, then the probability of having hypertension conditional on M-O confounders (age, gender, SES markers [SES is also affected by the exposure, and why we have to use MSMs in the first place]). 

## Numerator model for mediator
```{r num med, echo = TRUE}
# Prepping some lists/variables for for-loop 
m <- max(imp_stacked$".imp") # number of imputed datasets
num_htn_adct <- list() # for fitted values
num_med <- list() # numerator for htn 

# For-loop to obtain numerator model for exposure 
for (i in seq_along(1:m)){
  
  # extract one imputed dataset at a time
  data <- imp_stacked %>% filter(`.imp` == i)
  
  # multinomial regression to obtain unconditional prob 
  # of being in a race/ethnic group
  num_htn_adct[[i]] <- glm(as.factor(has_htn) ~ 1,
                           family = binomial(link = "logit"),
                           data = data)
  
  # obtaining fitted values 
  num_med[[i]] <- num_htn_adct[[i]]$fitted.values %>%
    as.data.frame() %>%
  rename(num_med = ".")
}

# checking probabilities
str(num_med)
summary(num_med[[20]]) # switch index to check all datasets

# cleaning up workspace for next section
rm(i, m, data, num_htn_adct)
```
## Denominator model for mediator
```{r den med, echo = TRUE}
# Prepping some lists/variables for for-loop 
m <- max(imp_stacked$".imp") # number of imputed datasets
den_htn_adct <- list() # for fitted values
den_med <- list() # denominator for htn

# For-loop to obtain numerator model for exposure 
for (i in seq_along(1:m)){
  
  # extract one imputed dataset at a time
  data <- imp_stacked %>% filter(`.imp` == i)
  
  # logistic regression to obtain conditional probability 
  den_htn_adct[[i]] <- glm(as.factor(has_htn) ~
                             as.factor(ethnicity) +
                             age_1 + # using baseline age 
                             as.factor(gender) +
                             # SES variables 
                             edu + 
                             income +
                             as.factor(hasnoinsurance) + 
                             # proximal risk factors
                             bmi +
                             rapa_1_total + # physical act scores
                             rapa_2_total + 
                             as.factor(smkever) + 
                             # lab values for cardiometabolic RF
                             ldl + 
                             gluc + 
                             a1c + 
                             egfr_nonaa + 
                             choltot + 
                             # clinical dx vars
                             as.factor(cdx_dyslipid) + 
                             as.factor(cdx_dm),
                           family = binomial(link = "logit"),
                           data = data)
  
  # obtaining fitted values 
  den_med[[i]] <- den_htn_adct[[i]]$fitted.values %>% 
    as.data.frame() %>%
    rename(den_med = ".")
}

# checking probabilities
## should be the same since we're just estimating unconditioanl probs here 
str(den_med)
summary(den_med[[20]]) # switch index to check all datasets

# cleaning up workspace for next section
rm(i, m, data, den_htn_adct)
```
## Calculating mediator weights
```{r med IPW, echo = TRUE}
# Prepping some lists/variables for for-loop 
m <- max(imp_stacked$".imp") # number of imputed datasets
imp_stacked_med <- list() # list for mediator weights 

# For-loop to obtain numerator model for exposure 
for (i in seq_along(1:m)){
  
  # extract one imputed dataset at a time
  data <- imp_stacked %>% filter(`.imp` == i)
  
  # Creating stabilized IPW for exposure
  imp_stacked_med[[i]] <- data %>%
  
  # getting probabilities from the models above
  bind_cols(num_med[[i]], 
            den_med[[i]]) %>% 

  # creating numerators based on mediator status
  mutate(num_med_exp = case_when(
    has_htn == 1 ~ num_med,
    has_htn == 0 ~ 1-num_med,
    TRUE ~ NA)) %>%
  
  # creating denominators based on mediator status
  mutate(den_med_exp = case_when(
    has_htn == 1 ~ den_med,
    has_htn == 0 ~ 1-den_med,
    TRUE ~ NA)) %>%
  
  # creating mediator weights
  mutate(sw_med = (num_med_exp/den_med_exp))
}
```
## Examining mediator IPWs
Weights mean ~ 1, none >10. 
```{r check IPW med, echo = TRUE}
# switch index to check each dataset separately 
summary(imp_stacked_med[[5]]$num_med_exp)
describeBy(imp_stacked_med[[1]]$num_med_exp, 
           imp_stacked_med[[1]]$has_htn, 
           mat = TRUE) 

summary(imp_stacked_med[[1]]$den_med_exp)
describeBy(imp_stacked_med[[1]]$den_med_exp, 
           imp_stacked_med[[1]]$has_htn, 
           mat = TRUE) 

summary(imp_stacked_med[[20]]$sw_med) # mean ~1, max 8.46
describeBy(imp_stacked_med[[20]]$sw_med, 
           imp_stacked_med[[20]]$has_htn, 
           mat = TRUE) 

bal.tab(has_htn ~ 
          ethnicity +
          age_1 + # using baseline age 
          gender +
          # SES variables 
          edu + 
          income +
          hasnoinsurance + 
          # proximal risk factors
          bmi +
          rapa_1_total + # physical act scores
          rapa_2_total + 
          smkever,
        data = imp_stacked_med[[5]],
        weights = "sw_med")

# cleaning up work space
rm(i, m, num_med, den_med)
```

# Selection weights 
This accounts for selection into the imaging cohort, in this case, who got an PET and had tau measured. In theory, this would be the same as the tau-PET measure, but we will estimate separately for each outcome because N's are still different even for same imaging modality. 

## Numerator model for selection
```{r num sel, echo = TRUE}
# Prepping some lists/variables for for-loop 
m <- max(imp_stacked$".imp") # number of imputed datasets
sel_adct <- list() # for fitted values
num_sel_adct <- list() # numerator for selection into the subsample 

# For-loop to obtain numerator model for exposure 
for (i in seq_along(1:m)){
  
  # extract one imputed dataset at a time
  data <- imp_stacked %>% filter(`.imp` == i)
  
  # logistic regression, prob of being in the WMHV sample 
  sel_adct[[i]] <- glm(as.factor(hasctv2) ~ 1,
                       family = binomial(link = "logit"),
                       data = data)
  
  # obtaining fitted values 
  num_sel_adct[[i]] <- sel_adct[[i]]$fitted.values %>%
    as.data.frame() %>%
  rename(num_sel = ".")
}

# checking probabilities
str(num_sel_adct)
summary(num_sel_adct[[5]]) # switch index to check all datasets

# cleaning up workspace for next section
rm(i, m, data, sel_adct)
```
## Denominator model for selection 
```{r den sel, echo = TRUE}
# Prepping some lists/variables for for-loop 
m <- max(imp_stacked$".imp") # number of imputed datasets
sel_adct <- list() # for fitted values
den_sel_adct <- list() # numerator for selection into the subsample 

# For-loop to obtain numerator model for exposure 
for (i in seq_along(1:m)){
  
  # extract one imputed dataset at a time
  data <- imp_stacked %>% filter(`.imp` == i)
  
  # logistic regression, prob of being in the WMHV sample 
  sel_adct[[i]] <- glm(as.factor(hasctv2) ~ 
                         as.factor(ethnicity) +
                         age_1 + # using baseline age 
                         as.factor(gender) +
                         # SES variables 
                         edu + 
                         income +
                         as.factor(hasnoinsurance) +
                         socsupptot + 
                         # proximal risk factors
                         bmi +
                         rapa_1_total + # physical act scores
                         rapa_2_total + 
                         as.factor(smkever) + 
                         gds_total + 
                         # lab values for cardiometabolic RF
                         ldl +
                         gluc +
                         a1c + 
                         egfr_nonaa + 
                         choltot + 
                         # clinical dx vars
                         as.factor(cdx_dep) +
                         as.factor(cdx_dyslipid) + 
                         as.factor(cdx_cvd) + 
                         as.factor(cdx_dm), 
                       family = binomial(link = "logit"),
                       data = data)
  
  # obtaining fitted values 
  den_sel_adct[[i]] <- sel_adct[[i]]$fitted.values %>%
    as.data.frame() %>%
  rename(den_sel = ".")
}

# checking probabilities
str(den_sel_adct)
summary(den_sel_adct[[20]]) # switch index to check all datasets

# cleaning up workspace for next section
rm(i, m, data, sel_adct)
```
## Calculating selection weights
```{r sel IPW, echo = TRUE}
# Prepping some lists/variables for for-loop 
m <- max(imp_stacked$".imp") # number of imputed datasets
imp_stacked_sel <- list() # list for selection weights 

# For-loop to obtain numerator model for exposure 
for (i in seq_along(1:m)){
  
  # extract one imputed dataset at a time
  data <- imp_stacked %>% filter(`.imp` == i)
  
  # Creating stabilized IPW for selection 
  imp_stacked_sel[[i]] <- data %>%
    
    # getting probabilities from the models above
    bind_cols(num_sel_adct[[i]], 
              den_sel_adct[[i]]) %>% 
    
    # creating numerators based on mediator status
    mutate(num_sel_f = case_when(
      hasctv2 == 1 ~ num_sel,
      hasctv2 == 0 ~ 1-num_sel,
      TRUE ~ NA)) %>%
    
    # creating denominators based on mediator status
    mutate(den_sel_f = case_when(
      hasctv2 == 1 ~ den_sel,
      hasctv2 == 0 ~ 1-den_sel,
      TRUE ~ NA)) %>%
    
    # creating mediator weights
    mutate(sw_sel = (num_sel_f/den_sel_f))
}
```
## Examining selection IPWs
Weights mean ~ 1, max 9. 
```{r check sel med, echo = TRUE}
# switch index to check each dataset separately 
summary(imp_stacked_sel[[5]]$num_sel_f)
describeBy(imp_stacked_sel[[5]]$num_sel_f, 
           imp_stacked_sel[[5]]$hasabv2, 
           mat = TRUE) 

summary(imp_stacked_sel[[5]]$den_sel_f)
describeBy(imp_stacked_sel[[5]]$den_sel_f, 
           imp_stacked_sel[[5]]$hasabv2, 
           mat = TRUE) 

summary(imp_stacked_sel[[20]]$sw_sel) 
describeBy(imp_stacked_sel[[20]]$sw_sel, 
           imp_stacked_sel[[20]]$hasabv2, 
           mat = TRUE) 

bal.tab(hasctv2 ~ 
          ethnicity +
          age_1 + # using baseline age 
          gender +
          # SES variables 
          edu + 
          income +
          hasnoinsurance + 
          socsupptot + 
          # proximal risk factors
          bmi +
          rapa_1_total + # physical act scores
          rapa_2_total + 
          smkever + 
          gds_total + 
          # lab values for cardiometabolic RF
          ldl + 
          gluc + 
          a1c + 
          egfr_nonaa + 
          choltot + 
          # clinical dx vars
          cdx_dep +
          cdx_dyslipid + 
          cdx_cvd +
          cdx_dm,
        data = imp_stacked_sel[[5]],
        weights = "sw_sel")

# cleaning up work space
rm(i, m, data, num_sel_adct, den_sel_adct)
```
# Creating total weights
For exposure weights, we will multiply exposure * selection weights. For the mediator weights, we include exposure, mediator, and selection weights. 
```{r IPW with all, echo = TRUE}
# Prepping some lists/variables for for-loop 
m <- max(imp_stacked$".imp") # number of imputed datasets
imp_stacked_adct <- list() # list for mediator weights 

# For-loop to obtain numerator model for exposure 
for (i in seq_along(1:m)){
  
  # extract one imputed dataset at a time
  data <- imp_stacked %>% filter(`.imp` == i)
  
  # Creating stabilized IPW for exposure
  imp_stacked_adct[[i]] <- data %>%
    
    # getting probabilities from the models above
    bind_cols(sw_exp = imp_stacked_exp[[i]]$sw_exp, 
              sw_med = imp_stacked_med[[i]]$sw_med,
              sw_sel = imp_stacked_sel[[i]]$sw_sel) %>% 
    
    # creating final exposure weights
    mutate(sw_exp_sel = (sw_exp*sw_sel)) %>% 
    
    ## truncating at 1st and 99th percentile 
    mutate(sw_exp_f = case_when(
      sw_exp_sel < quantile(sw_exp_sel, 0.01) ~ quantile(sw_exp_sel, 0.01),
      sw_exp_sel > quantile(sw_exp_sel, 0.99) ~ quantile(sw_exp_sel, 0.99),
      TRUE ~ sw_exp_sel)) %>% 
    
    # creating final mediator weights
    mutate(sw_med_sel = (sw_exp*sw_med*sw_sel)) %>% 
    
    ## truncating at 1st and 99th percentile 
    mutate(sw_med_f = case_when(
      sw_med_sel < quantile(sw_med_sel, 0.01) ~ quantile(sw_med_sel, 0.01),
      sw_med_sel > quantile(sw_med_sel, 0.99) ~ quantile(sw_med_sel, 0.99),
      TRUE ~ sw_med_sel)) 
  
}
```

## Examining final IPWs
Final exposure weights mean ~ 1, and max ranging in the 7-8s. 

Final mediator weights mean ~ 1, but max ranging from 34-35s, will truncate (see above section for edits to code), and will be consistent and do this for both weights.
```{r check IPW all, echo = TRUE}
# switch index to check all datasets
summary(imp_stacked_adct[[20]]$sw_exp_f) 
describeBy(imp_stacked_adct[[20]]$sw_exp_f, 
           imp_stacked_adct[[20]]$ethnicity, 
           mat = TRUE) 

summary(imp_stacked_adct[[20]]$sw_med_f) 
describeBy(imp_stacked_adct[[20]]$sw_med_f, 
           imp_stacked_adct[[20]]$ethnicity, 
           mat = TRUE) 

# For exposure weights 
bal.tab(ethnicity ~
          age_1 + # using baseline age 
          gender +
          # SES variables 
          edu + 
          income +
          hasnoinsurance + 
          socsupptot + 
          # proximal risk factors
          bmi +
          rapa_1_total + # physical act scores
          rapa_2_total + 
          smkever + 
          gds_total + 
          # lab values for cardiometabolic RF
          ldl + 
          gluc + 
          a1c + 
          egfr_nonaa + 
          choltot + 
          # clinical dx vars
          cdx_dep +
          cdx_dyslipid + 
          cdx_cvd +
          cdx_dm,
        data = imp_stacked_adct[[1]],
        weights = "sw_exp_f",
        which.treat = .all)

exp_cov <- do.call(rbind, imp_stacked_adct) %>% 
  select(c("age_1", "ethnicity", "gender", "edu", "income", "hasnoinsurance", "socsupptot", "bmi", "rapa_1_total", "rapa_2_total", "smkever", "gds_total", "ldl", "gluc", "a1c", "egfr_nonaa", "choltot", "cdx_dep", "cdx_dyslipid", "cdx_cvd", "cdx_dm", "sw_exp_f"))

cov_names <- data.frame(
  old = c("age_1", "ethnicity", "gender", "edu", "income", "hasnoinsurance", "socsupptot", "bmi", "rapa_1_total", "rapa_2_total", "smkever", "gds_total", "ldl", "gluc", "a1c", "egfr_nonaa", "choltot", "cdx_dep", "cdx_dyslipid", "cdx_cvd", "cdx_dm", "sw_exp_f"),
  new = c("Age (Years)", "Race/Ethnicity", "Sex/Gender", "Years of Education", "Income", "Has No Insurance", "Social Support Score", "BMI", "Physical Activity Score (Aerobic)", "Physical Activity Score (Strength)", "Ever Smoked", "GDS Score", "LDL-C", "Glucose", "A1C", "EGFR-nonAA", "Total Cholesterol", "Depression", "Dyslipidemia", "CVD", "Diabetes", "IPW for Exposure") ) 

love.plot(ethnicity ~
          age_1 + # using baseline age 
          gender +
          # SES variables 
          edu + 
          income +
          hasnoinsurance + 
          socsupptot + 
          # proximal risk factors
          bmi +
          rapa_1_total + # physical act scores
          rapa_2_total + 
          smkever + 
          gds_total + 
          # lab values for cardiometabolic RF
          ldl + 
          gluc + 
          a1c + 
          egfr_nonaa + 
          choltot + 
          # clinical dx vars
          cdx_dep +
          cdx_dyslipid + 
          cdx_cvd +
          cdx_dm,
          weights = "sw_exp_f",
          data = exp_cov,
          threshold = c(m=0.2),
          var.names = cov_names,
          stars = "raw", 
          which.treat = .all,
          title = "Covariate Balance for Exposure Weights (AD meta-ROI CT)") -> lp_exp_adct

ggsave("./results/lp_exp_adct.jpeg",
       dpi = 400,
       plot = lp_exp_adct)

# For mediator weights 
bal.tab(has_htn ~
          age_1 + # using baseline age 
          gender +
          # SES variables 
          edu + 
          income +
          hasnoinsurance + 
          socsupptot + 
          # proximal risk factors
          bmi +
          rapa_1_total + # physical act scores
          rapa_2_total + 
          smkever + 
          gds_total + 
          # lab values for cardiometabolic RF
          ldl + 
          gluc + 
          a1c + 
          egfr_nonaa + 
          choltot + 
          # clinical dx vars
          cdx_dep +
          cdx_dyslipid + 
          cdx_cvd +
          cdx_dm,
        data = imp_stacked_adct[[1]],
        weights = "sw_med_f",
        which.treat = .all)

med_cov <- do.call(rbind, imp_stacked_adct) %>% 
  select(c("age_1", "has_htn", "ethnicity", "gender", "edu", "income", "hasnoinsurance", "socsupptot", "bmi", "rapa_1_total", "rapa_2_total", "smkever", "gds_total", "ldl", "gluc", "a1c", "egfr_nonaa", "choltot", "cdx_dep", "cdx_dyslipid", "cdx_cvd", "cdx_dm", "sw_med_f"))

cov_names <- data.frame(
  old = c("age_1", "has_htn", "ethnicity", "gender", "edu", "income", "hasnoinsurance", "socsupptot", "bmi", "rapa_1_total", "rapa_2_total", "smkever", "gds_total", "ldl", "gluc", "a1c", "egfr_nonaa",  "choltot", "cdx_dep", "cdx_dyslipid", "cdx_cvd", "cdx_dm", "sw_med_f"),
  new = c("Age (Years)", "Has HTN", "Race/Ethnicity", "Sex/Gender", "Years of Education", "Income", "Has No Insurance", "Social Support Score", "BMI", "Physical Activity Score (Aerobic)", "Physical Activity Score (Strength)", "Ever Smoked", "GDS Score", "LDL-C", "Glucose", "A1C", "EGFR-nonAA",  "Total Cholesterol", "Depression", "Dyslipidemia", "CVD", "Diabetes", "IPW for Mediator") ) 

love.plot(has_htn ~
          age_1 + # using baseline age 
          gender +
          ethnicity + 
          # SES variables 
          edu + 
          income +
          hasnoinsurance + 
          socsupptot + 
          # proximal risk factors
          bmi +
          rapa_1_total + # physical act scores
          rapa_2_total + 
          smkever + 
          gds_total + 
          # lab values for cardiometabolic RF
          ldl + 
          gluc + 
          a1c + 
          egfr_nonaa + 
          choltot + 
          # clinical dx vars
          cdx_dep +
          cdx_dyslipid + 
          cdx_cvd +
          cdx_dm,
          weights = "sw_med_f",
          data = med_cov,
          threshold = c(m=0.2),
          var.names = cov_names, 
          stars = "raw", 
          which.treat = .all,
          title = "Covariate Balance for HTN Mediator Weights (AD meta-ROI CT)") -> lp_med_adct

ggsave("./results/lp_med_adct.jpeg",
       dpi = 400,
       plot = lp_med_adct)

# table of weights per imputed dataset
do.call(rbind, imp_stacked_adct) %>%
  as.data.frame() %>% 
  group_by(`.imp`) %>% 
  summarise(mean_expIPW = mean(sw_exp_f),
            sd_expIPW = sd(sw_exp_f),
            min_expIPW = min(sw_exp_f),
            max_expIPW = max(sw_exp_f),
            mean_medIPW = mean(sw_med_f),
            sd_medIPW = sd(sw_med_f),
            min_medIPW = min(sw_med_f),
            max_medIPW = max(sw_med_f)) %>%
  rename("Mean (Exposure IPW)" = mean_expIPW,
         "SD (Exposure IPW)" = sd_expIPW,
         "Min (Exposure IPW)" = min_expIPW,
         "Max (Exposure IPW)" = max_expIPW,
         "Mean (Mediator IPW)" = mean_medIPW,
         "SD (Mediator IPW)" = sd_medIPW,
         "Min (Mediator IPW)" = min_medIPW,
         "Max (Mediator IPW)" = max_medIPW,
         "Imputation" = `.imp`) %>% 
  mutate_if(is.numeric, round, 2) %>% 
  gt() -> tbl_wgts_adct

# saving tables
gtsave(tbl_wgts_adct, file = "./results/tbl_wgts_adct.docx")

# saving dataset for analysis
save(imp_stacked_adct, file = "./analysis data/imp_stacked_adct.Rdata")

# cleaning up workspace
rm(i, m, data, imp_stacked_exp, imp_stacked_med, imp_stacked_sel, cov_names, lp_exp_adct, lp_med_adct, med_cov)
```

# Estimating TE and CDEs for tau 
## Total effect
For total effect, we can model scale(taumedtempsuvr_2) as a function of race/ethnicity, weighted by the exposure IPW.
```{r te mttau, echo = TRUE}
# loading stacked imputed data 
load("./analysis data/imp_stacked_adct.Rdata") 

# creating survey design in order to use weights
m <- max(imp_stacked$".imp") # number of imputed datasets
te_adct <- list() # list for mediator weights 

# For-loop to estimate MSM for total effect of race/ethnicity on logWMHV
for (i in seq_along(1:m)){
  
  # creating survey design to implement weights 
  design_te_adct <- svydesign(ids = ~1, 
                              weights = ~sw_exp_f, 
                              data = imp_stacked_adct[[i]])
  
  # estimating total effect of race/ethnicity on log-transformed WMHV 
  te_adct[[i]] <- svyglm(scale(ctmetaroi_2) ~
                           as.factor(ethnicity) + 
                           as.factor(mriscanner_2),
                         design = design_te_adct) 
}

# Pooling estimates across imputations 
pool_te_adct <- as.mira(te_adct) %>% pool()
summary(pool_te_adct)

# Making results presentable 
te_adct_res <- summary(pool_te_adct, conf.int = TRUE) %>%
  as.data.frame() %>% 
  mutate("Estimate" = estimate) %>% 
  mutate("LCL" = conf.low) %>% 
  mutate("UCL" = conf.high) %>%
  rename("p-value" = p.value) %>% 
  mutate(across(is.numeric, round, 2)) %>%
  mutate("Group" = case_when(
    term == "as.factor(ethnicity)Black" ~ "Black",
    term == "as.factor(ethnicity)Hispanic" ~ "Hispanic")) %>% 
  select(Group, Estimate, LCL, UCL, "p-value") %>% 
  filter(Group %in% c("Black", "Hispanic")) 

te_adct_res %>% gt()

# cleaning up workspace
rm(i, m, data, design_te_adct, te_adct)
```

## Controlled direct effects
For CDE, we can model scale(absuvr_2) as a function of the race/ethnicity, hypertension, and their interaction, weighted by the SW as calculated by the cumulative product of both the exposure and mediator weights. The estimate for the Black and Hispanic reflect the CDE of those exposures, holding HTN =0, in other words, what is the effect of race/ethnicity if we control hypertension. 

### Setting HTN = 0
```{r cde htn0, echo = TRUE}
# creating survey design in order to use weights
m <- max(imp_stacked$".imp") # number of imputed datasets
cde_htn0 <- list() # list for mediator weights 

# For-loop to estimate MSM for total effect of race/ethnicity on adct
for (i in seq_along(1:m)){
  
  # creating survey design to implement weights
  design_cde_adct <- svydesign(ids = ~1, 
                               weights = ~sw_med_f, 
                               data = imp_stacked_adct[[i]])
  
  # estimating CDE of race/ethnicity on log-transformed WMHV, controlling for HTN 
  cde_htn0[[i]] <- svyglm(scale(ctmetaroi_2) ~
                            as.factor(ethnicity)*as.factor(has_htn) +
                            as.factor(mriscanner_2),
                          design = design_cde_adct)
}

# Pooling estimates across imputations 
pool_cde_adct <- as.mira(cde_htn0) %>% pool()
summary(pool_cde_adct)

# Making results presentable 
cde_htn0_res <- summary(pool_cde_adct, conf.int = TRUE) %>%
  as.data.frame() %>% 
  mutate("Estimate" = estimate) %>% 
  mutate("LCL" = conf.low) %>% 
  mutate("UCL" = conf.high) %>%
  rename("p-value" = p.value) %>% 
  mutate(across(is.numeric, round, 2)) %>%
  mutate("Group" = case_when(
    term == "as.factor(ethnicity)Black" ~ "Black",
    term == "as.factor(ethnicity)Hispanic" ~ "Hispanic",
    term == "as.factor(has_htn)1" ~ "Hypertension",
    term == "as.factor(ethnicity)Black:as.factor(has_htn)1" ~ "Black*HTN",
    term == "as.factor(ethnicity)Hispanic:as.factor(has_htn)1" ~ "Hispanic*HTN")) %>% 
  select(Group, Estimate, LCL, UCL, "p-value") %>% 
  filter(Group %in% c("Black", "Hispanic")) 

cde_htn0_res %>% gt()

# cleaning up workspace
rm(i, m, data, design_cde_adct, cde_htn0)
```

### Setting HTN = 1
```{r htn1}
# Prepping list
m <- length(imp_stacked_adct) # number of imputed datasets
cde_htn1 <- list() # list for mediator weights, setting HTN=1 
imp_stacked_adct2 <- list() # list for data with has_htn level changed to reference = 1

for (i in seq_along(1:m)){
  
  imp_stacked_adct2[[i]] <- imp_stacked_adct[[i]] %>%
    mutate_at(c("has_htn"), 
              factor, 
              levels = c(1,0)) 
  
  # creating survey design to implement weights
  design_cde_adct <- svydesign(ids = ~1, 
                               weights = ~sw_med_f, 
                               data = imp_stacked_adct2[[i]])
  
  # estimating CDE of race/ethnicity on AD meta-ROI CT, where HTN = 1 as the reference level (mediator and exp*med term drop from model when mediator=1)
  cde_htn1[[i]] <- svyglm(scale(ctmetaroi_2)  ~
                            as.factor(ethnicity)*(has_htn-1)+
                            as.factor(mriscanner_2),
                            design = design_cde_adct)
  
}

# Pooling estimates across imputations 
pool_htn1 <- as.mira(cde_htn1) %>% pool()
summary(pool_htn1)

# Making results presentable 
cde_htn1_res <- summary(pool_htn1, conf.int = TRUE) %>%
  as.data.frame() %>% 
  mutate("Estimate" = estimate) %>% 
  mutate("LCL" = conf.low) %>% 
  mutate("UCL" = conf.high) %>%
  rename("p-value" = p.value) %>% 
  mutate(across(is.numeric, round, 2)) %>%
  mutate("Group" = case_when(
    term == "as.factor(ethnicity)Black" ~ "Black",
    term == "as.factor(ethnicity)Hispanic" ~ "Hispanic",
    term == "has_htn0" ~ "Hypertension",
    term == "as.factor(ethnicity)Black:has_htn0" ~ "Black*HTN",
    term == "as.factor(ethnicity)Hispanic:has_htn0" ~ "Hispanic*HTN")) %>% 
  select(Group, Estimate, LCL, UCL, "p-value") %>% 
  filter(Group %in% c("Black", "Hispanic")) 

cde_htn1_res %>% gt()

# cleaning up workspace
rm(i, m, data, design_cde_wmhv, cde_wmhv)
```

# Outputting tau results 
```{r res wmhv, echo = TRUE}
adct_res <- bind_rows(te_adct_res,
                      cde_htn0_res,
                      cde_htn1_res) %>% 
  gt() %>% 
  tab_row_group(
    label = "Controlled Direct Effects of Race/Ethnicity on AD meta-ROI CT, Setting HTN = 1",
    rows = 5:6) %>% 
  tab_row_group(
    label = "Controlled Direct Effects of Race/Ethnicity on AD meta-ROI CT, Setting HTN = 0",
    rows = 3:4) %>% 
  tab_row_group(
    label = "Total Effects of Race/Ethnicity on AD meta-ROI CT",
    rows = 1:2) 

adct_res

save(adct_res, file = "./results/adct_res") # saving gt version, in case we want to merge gt
adct_res %>% gtsave("./results/adct_res.docx")
```


